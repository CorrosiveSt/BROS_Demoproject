tile_master_table = {
  sw = {},
  space = {}
}

-- args[.start_pos, .range]
function sendPulse_HL(args) -- Returns tile_master_table to ship
  for _,v in ipairs(args.start_pos) do
    pulse(v)
  end
  remDuplicates(tile_master_table.sw)
  remDuplicates(tile_master_table.space)
  return tile_master_table
end

--[[ -- ]]--

function pulse(start_pos)
  self.setPosition(start_pos)
  local toPulseHDG = {}

  for _,found_sw in ipairs(self.getObjects()) do
    local angleToSw = validateSw(found_sw)
    if angleToSw ~= nil then
      local found_sw_table = {
        obj = found_sw,
        hdg = {angleToSw}
      }
      table.insert(toPulseSw, found_sw_table)
    end
  end

  for _,angle in ipairs(found_sw_table) do
    local target_pos = found_sw_table.obj.getPosition()
    local self_pos = self.getPosition()
    target_pos[2] = self_pos[2]

    local pulse = Physics.cast({
      origin       = found_sw_table.obj.getPosition(),
      direction    = Vector.between(self.getPosition(), found_sw_table.obj.getPosition()),
      type         = 2,
      size         = {1,1,1},
      debug        = true,
    })

    for _,s_cast in ipairs(pulse) do
      if s_cast.hit_object.hasTag("cast-checked") then
        log("pulse: already hit space hit again!")

      elseif s_cast.hit_object.hasTag("Space") then
        table.insert(tile_master_table.space, s_cast.hit_object)
        s_cast.hit_object.addTag("cast_checked")

      elseif s_cast.hit_object.hasTag("spaceway") then
        table.insert(tile_master_table.sw, s_cast.hit_object)

      else
        log("pulse: wrong type of tile! No tags?")
        s_cast.hit_object.highlightOn("Red", 5)
      end
    end
  end
end

--[[ -- ]]--

function validateSw(found_sw) -- Returns an angle if valid, nil if invalid
  local hdg_to_target = Vector.between(self.getPosition(), found_sw.getPosition():heading('y'))
  if hdg_to_target < 0 then
    hdg_to_target = hdg_to_target + 180
  end
  local target_hdg = found_sw.getRotation().y

  hdg_to_target = clampTo60(hdg_to_target)
  target_hdg = clampTo60(target_hdg)

  local sum = hdg_to_target - target_hdg

  if sum == 180 or sum == -180 then
    return hdg_to_target
  else
    log("validateSw: " .. hdg_to_target .. " was not valid!")
    return nil
  end
end

--[[ -- ]]--

function clampTo60(angle)
  local res = math.floor(angle/60+0.5)*60
  if res == 360 then
    res = 0
  end
  return res -- Returns value closest to increments of 60
end

--[[ -- ]]--
