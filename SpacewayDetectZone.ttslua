-- INIT: Get needed GUIDS from Global

-- INIT: Make variables for object references

-- SETUP: init scriptwide tables & variables
cast_tiles_space = {}
cast_tiles_sw = {}
reset_pos = {0, -10, 0}

-- SETUP: reset position to under the table
self.setPosition(reset_pos)

--[[--]]--

function sendPulse_HL(params)
  -- Update range
  local range = params.range
  print("range:" .. tostring(range))
  -- Move to start_pos
  self.setPosition(params.start_pos)

  -- Gather objects, for each get values ready for compareHDG()
  -- NOTE that the argument for the amount of frames in under this all
  Wait.frames(function()
  for _, obj in ipairs(self.getObjects()) do
    -- Find target pos and hdg, and normalize values to y
    local target_pos = obj.getPosition()
    local target_hdg = obj.getRotation()

    target_pos[2] = params.start_pos[2]
    target_hdg = target_hdg[2]

    local result = compareHDG(target_pos, target_hdg)
    if result ~= nil then
      castTo(result)
    end
  end
  -- It looks funky here but trust me bro, this ends the Wait.frames function
  end, 5)

  -- Check if there's range to go
  if range > 0 then
      for _, tiles in ipairs(cast_tiles_space) do
        local new = {
          start_pos = tiles.getPosition(),
          range = range - 1
        }
        sendPulse_HL(new)
      end
  end
end

--[[--]]--

function compareHDG(target_pos, target_hdg)
  -- Draw a vector from self to target_pos
  local vec_toTarget = Vector.between(self.getPosition(), target_pos)
  local vec_toTarget_y = vec_toTarget:heading('y')
  if vec_toTarget_y < 0 then
    vec_toTarget_y = vec_toTarget_y + 180
  end
  -- Clamp the vector and target_hdg to increments of 60
  target_hdg = math.floor(target_hdg/60+0.5)*60
  vec_toTarget_y = math.floor(vec_toTarget_y/60+0.5)*60
  -- Compare the values
  local result = math.abs(vec_toTarget_y - target_hdg)
  -- Return direction vector if valid, otherwise nil
  if result == 180 or result == 0 then
    return vec_toTarget
  else
    return nil
  end
end

--[[--]]--

function castTo(target_hdg)
  -- Do a physics cast towards vec_toTarget
  local cast_tiles = Physics.cast({
    origin       = self.getPosition(),
    direction    = target_hdg,
    type         = 2,      -- Add tag to the tile called "range-checked"
    size         = {1,1,1},
    debug        = true,
  })

  local void_count = 0
  for _, obj in ipairs(cast_tiles) do
    -- Filter results
    if void_count < 2 then
      if obj.hit_object.hasTag("range-checked") then
        void_count = void_count + 1

      elseif obj.hit_object.hasTag("Space") then
        -- Add space tile to its own table cast_tiles_space and mark as checked
        table.insert(cast_tiles_space, obj.hit_object)
        obj.hit_object.addTag("range-checked")
        void_count = void_count + 1

      elseif obj.hit_object.hasTag("spaceway") then
        -- Add spaceway tile to its own table cast_tiles_sw
        table.insert(cast_tiles_sw, obj.hit_object)
      end
    end
  end
end

--[[--]]--

function onChat(message, player)
  if message == "clear" then
    cast_tiles_space = {}
    cast_tiles_sw = {}
    self.setPosition(reset_pos)
  end
end

function startDiscovery()
  --TODO actual discovery
  print("Started discovery!")
end
