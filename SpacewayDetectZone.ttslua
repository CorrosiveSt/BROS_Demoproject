tile_master_table = {
  sw = {},
  space = {},
  to_pulse = {}
}

-- args[.start_pos, .range]
function sendPulse_HL(args) -- Returns tile_master_table to ship
  local rang = args.range
  pulse(args.start_pos)
  while rang > 0 do
    Wait.frames(function()
    -- Catch new values to pulse to, and reset the original table
    local to_pulse_buffer = tile_master_table.to_pulse
    tile_master_table.to_pulse = {}
    rang = rang - 1
    for _,v in ipairs(to_pulse_buffer) do
      pulse(v.getPosition()) 
    end
    end, 10)
  end
  highlightMasterTable(args.player_color)
end

--[[ -- ]]--

function pulse(start_pos)
  local sw_to_cast = {}

  self.setPosition(start_pos)

  Wait.frames(function()
    for _,found_sw in ipairs(self.getObjects()) do
      if validateSw(found_sw) ~= nil then
        table.insert(sw_to_cast, found_sw)
      end

    end

    for _,curr_sw in ipairs(sw_to_cast) do
      local target_pos = curr_sw.getPosition()
      local self_pos = self.getPosition()
      target_pos[2] = self_pos[2]
      castTo(self_pos, target_pos)
    end
  end , 5)
end

--[[ -- ]]--

function validateSw(found_sw) -- Returns an angle if valid, "invalid" if invalid

  local hdg_to_target = Vector.between(self.getPosition(), found_sw.getPosition()):heading('y')
  if hdg_to_target < 0 then
    hdg_to_target = hdg_to_target + 360
  end

  local target_hdg = found_sw.getRotation().y

  hdg_to_target = clampTo60(hdg_to_target)
  target_hdg = clampTo60(target_hdg)

  local sum = hdg_to_target - target_hdg

  if sum == 180 or sum == -180 or sum == 0 then
    return hdg_to_target
  else
    return nil
  end
end

--[[ -- ]]--

function clampTo60(angle)
  local res = math.floor(angle/60+0.5)*60
  if res == 360 then
    res = 0
  end
  return res -- Returns value closest to increments of 60
end

--[[ -- ]]--

function castTo(sel_pos, tar_pos)
  local ballcast = Physics.cast({
    origin       = sel_pos,
    direction    = Vector.between(sel_pos, tar_pos),
    type         = 2,
    size         = {1,1,1},
    debug        = true,
  })
  local spacehit = 0
  for _,item in ipairs(ballcast) do
    if item.hit_object.hasTag("range-checked") and spacehit < 2 then
      spacehit = spacehit + 1

    elseif item.hit_object.hasTag("Space") and spacehit < 2 then
      table.insert(tile_master_table.space, item.hit_object)
      table.insert(tile_master_table.to_pulse, item.hit_object)
      spacehit = spacehit + 1
      item.hit_object.addTag("range-checked")

    elseif item.hit_object.hasTag("spaceway") and spacehit < 2 then
      table.insert(tile_master_table.sw, item.hit_object)
    end
  end
end

--[[ -- ]]--

function highlightMasterTable(hl_color)
  if hl_color == "off" then
    for _,v1 in ipairs(tile_master_table.space) do
      v1.highlightOff()
      v1.removeTag("range-checked")
    end
    for _,v2 in ipairs(tile_master_table.sw) do
      v2.highlightOff()
    end
    tile_master_table = {
      sw = {},
      space = {},
      to_pulse = {}
    }
  else
    for _,v1 in ipairs(tile_master_table.space) do
      v1.highlightOn(hl_color)
    end
    for _,v2 in ipairs(tile_master_table.sw) do
      v2.highlightOn(hl_color)
    end
  end
end
--[[ -- ]]--
