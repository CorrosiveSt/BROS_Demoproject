tile_master_table = {
  sw = {},
  space = {}
}

-- args[.start_pos, .range]
function sendPulse_HL(args) -- Returns tile_master_table to ship
  pulse(args.start_pos)
end

--[[ -- ]]--

function pulse(start_pos)
  pulse("Starting a pulse at " .. tostring(start_pos))
  self.setPosition(start_pos)
  local found_sw_table = {}

  for _,found_sw in ipairs(self.getObjects()) do
    if validateSw(found_sw) ~= nil then
      table.insert(found_sw_table, found_sw)
    end
  end

  for _,curr_sw in ipairs(found_sw_table) do
    local target_pos = curr_sw.getPosition()
    local self_pos = self.getPosition()
    target_pos[2] = self_pos[2]

    local pulse = Physics.cast({
      origin       = curr_sw.getPosition(),
      direction    = Vector.between(self.getPosition(), curr_sw.getPosition()),
      type         = 2,
      size         = {1,1,1},
      debug        = true,
    })

    print("Cast done!")

    for _,s_cast in ipairs(pulse) do
      if s_cast.hit_object.hasTag("cast-checked") then
        log("pulse: already hit space hit again!")

      elseif s_cast.hit_object.hasTag("Space") then
        table.insert(tile_master_table.space, s_cast.hit_object)
        s_cast.hit_object.addTag("cast_checked")

      elseif s_cast.hit_object.hasTag("spaceway") then
        table.insert(tile_master_table.sw, s_cast.hit_object)

      else
        log("pulse: wrong type of tile! No tags?")
        s_cast.hit_object.highlightOn("Red", 5)
      end
    end
  end
end

--[[ -- ]]--

function validateSw(found_sw) -- Returns an angle if valid, nil if invalid
  local hdg_to_target = Vector.between(self.getPosition(), found_sw.getPosition():heading('y'))
  print(tostring(hdg_to_target))
  if hdg_to_target < 0 then
    hdg_to_target = hdg_to_target + 180
  end
  local target_hdg = found_sw.getRotation().y

  hdg_to_target = clampTo60(hdg_to_target)
  target_hdg = clampTo60(target_hdg)

  local sum = hdg_to_target - target_hdg

  if sum == 180 or sum == -180 then
    return hdg_to_target
  else
    log("validateSw: " .. hdg_to_target .. " was not valid!")
    return nil
  end
end

--[[ -- ]]--

function clampTo60(angle)
  local res = math.floor(angle/60+0.5)*60
  if res == 360 then
    res = 0
  end
  return res -- Returns value closest to increments of 60
end

--[[ -- ]]--

function remDuplicates(toSort_table)
  local hash = {}
  local res = {}
  for _,v in ipairs(toSort_table) do
    if (not hash[v]) then
      res[#res+1] = v -- you could print here instead of saving to result table if you wanted
      hash[v] = true
    end
  end
end
